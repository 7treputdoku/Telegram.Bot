using System;
using System.Collections.Generic;
using System.Text;

namespace EnumSerializer.Generator;

public static class SourceGenerationHelper
{
    private const string Header = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the EnumSerializer.Generator source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable
";

    public const string EnumConverter = Header + @"
using System;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System.Runtime.CompilerServices;

namespace Telegram.Bot.Converters;

internal abstract class EnumConverter<TEnum> : JsonConverter<TEnum>
    where TEnum : Enum
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected abstract TEnum GetEnumValue(string value);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    protected abstract string GetStringValue(TEnum value);

    public override void WriteJson(JsonWriter writer, TEnum? value, JsonSerializer serializer) =>
        writer.WriteValue(GetStringValue(value!));

    public override TEnum ReadJson(
        JsonReader reader,
        Type objectType,
        TEnum existingValue,
        bool hasExistingValue,
        JsonSerializer serializer
    ) =>
        GetEnumValue(JToken.ReadFrom(reader).Value<string>());
}
";

    public static string GenerateConverterClass(StringBuilder sb, EnumInfo enumToGenerate)
    {
        sb.Append(Header);
        sb.Append(@"
using System;
using System.Collections.Generic;
using Telegram.Bot.Converters;
using Telegram.Bot.Types.Enums;
");

        if (!string.IsNullOrEmpty(enumToGenerate.Namespace))
        {
            sb.Append(@"
namespace ").Append(enumToGenerate.Namespace).Append(';');
        }

        sb.Append(@"
").Append("internal partial class ").Append(enumToGenerate.Name).Append("Converter").Append(": EnumConverter<").Append(enumToGenerate.Name).Append('>').Append(@"
{
    static readonly IReadOnlyDictionary<string, ").Append(enumToGenerate.Name).Append(@"> StringToEnum =
        new Dictionary<string, ").Append(enumToGenerate.Name).Append(@">
        {");
        foreach (var enumMember in enumToGenerate.Names) {
            sb.Append(@"
            {""").Append(enumMember.Value).Append(@""", ").Append(enumToGenerate.Name).Append('.').Append(enumMember.Key).Append("},");
        }
        sb.Append(@"
        };

    static readonly IReadOnlyDictionary<").Append(enumToGenerate.Name).Append(@", string> EnumToString =
        new Dictionary<").Append(enumToGenerate.Name).Append(@", string>
        {
            { 0, ""unknown"" },");
        foreach (var enumMember in enumToGenerate.Names)
        {
            sb.Append(@"
            {").Append(enumToGenerate.Name).Append('.').Append(enumMember.Key).Append(@", """).Append(enumMember.Value).Append(@"""},");
        }
        sb.Append(@"
        };

    protected override ").Append(enumToGenerate.Name).Append(@" GetEnumValue(string value) =>
        StringToEnum.TryGetValue(value, out var enumValue)
            ? enumValue
            : 0;

    protected override string GetStringValue(").Append(enumToGenerate.Name).Append(@" value) =>
        EnumToString.TryGetValue(value, out var stringValue)
            ? stringValue
            : throw new NotSupportedException();
}");

        return sb.ToString();
    }
}
